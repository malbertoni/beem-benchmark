type byte is 0..255

process _slave_1 (&_sem: byte, &_b: array 3 of byte) is
states _idle, _q0, _q1, _q2, _q3, _error_state

init to _idle

from _idle
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	to _q0

from _q0
	case (_b[0] = 1) of
	true -> null
	end case;
	_b[0] := 0;
	to _q1

from _q0
	case (_b[1] = 1) of
	true -> null
	end case;
	_b[1] := 0;
	to _q1

from _q0
	case (_b[2] = 1) of
	true -> null
	end case;
	_b[2] := 0;
	to _q1

from _q0
	case (((_b[0] <> 1) and (_b[1] <> 1)) and (_b[2] <> 1)) of
	true -> null
	end case;
	to _q1

from _q1
	case (_b[0] = 2) of
	true -> null
	end case;
	_b[0] := 1;
	to _q2

from _q1
	case (_b[1] = 2) of
	true -> null
	end case;
	_b[1] := 1;
	to _q2

from _q1
	case (_b[2] = 2) of
	true -> null
	end case;
	_b[2] := 1;
	to _q2

from _q1
	case (((_b[0] <> 2) and (_b[1] <> 2)) and (_b[2] <> 2)) of
	true -> null
	end case;
	to _error_state

from _q2
	case (_b[0] = 0) of
	true -> null
	end case;
	_b[0] := 2;
	to _q3

from _q2
	case (_b[1] = 0) of
	true -> null
	end case;
	_b[1] := 2;
	to _q3

from _q2
	case (_b[2] = 0) of
	true -> null
	end case;
	_b[2] := 2;
	to _q3

from _q2
	case (((_b[0] <> 0) and (_b[1] <> 0)) and (_b[2] <> 0)) of
	true -> null
	end case;
	to _error_state

from _q3
	_sem := 1;
	to _idle


process _slave_2 (&_sem: byte, &_b: array 3 of byte) is
states _idle, _q0, _q1, _q2, _q3, _error_state

init to _idle

from _idle
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	to _q0

from _q0
	case (_b[0] = 1) of
	true -> null
	end case;
	_b[0] := 0;
	to _q1

from _q0
	case (_b[1] = 1) of
	true -> null
	end case;
	_b[1] := 0;
	to _q1

from _q0
	case (_b[2] = 1) of
	true -> null
	end case;
	_b[2] := 0;
	to _q1

from _q0
	case (((_b[0] <> 1) and (_b[1] <> 1)) and (_b[2] <> 1)) of
	true -> null
	end case;
	to _q1

from _q1
	case (_b[0] = 2) of
	true -> null
	end case;
	_b[0] := 1;
	to _q2

from _q1
	case (_b[1] = 2) of
	true -> null
	end case;
	_b[1] := 1;
	to _q2

from _q1
	case (_b[2] = 2) of
	true -> null
	end case;
	_b[2] := 1;
	to _q2

from _q1
	case (((_b[0] <> 2) and (_b[1] <> 2)) and (_b[2] <> 2)) of
	true -> null
	end case;
	to _error_state

from _q2
	case (_b[0] = 0) of
	true -> null
	end case;
	_b[0] := 2;
	to _q3

from _q2
	case (_b[1] = 0) of
	true -> null
	end case;
	_b[1] := 2;
	to _q3

from _q2
	case (_b[2] = 0) of
	true -> null
	end case;
	_b[2] := 2;
	to _q3

from _q2
	case (((_b[0] <> 0) and (_b[1] <> 0)) and (_b[2] <> 0)) of
	true -> null
	end case;
	to _error_state

from _q3
	_sem := 1;
	to _idle


process _master_1 (&_change_to: byte, &_sem: byte, &_readers: byte, &_b: array 3 of byte) is
states _idle, _q0, _no_master, _master, _reading, _r0, _no_readers, _change, _r1

init to _idle

from _idle
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	to _q0

from _q0
	case (_b[0] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (_b[1] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (_b[2] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (((_b[0] <> 3) and (_b[1] <> 3)) and (_b[2] <> 3)) of
	true -> null
	end case;
	to _no_master

from _no_master
	case (_b[0] = 1) of
	true -> null
	end case;
	_b[0] := 3;
	to _master

from _no_master
	case (_b[1] = 1) of
	true -> null
	end case;
	_b[1] := 3;
	to _master

from _no_master
	case (_b[2] = 1) of
	true -> null
	end case;
	_b[2] := 3;
	to _master

from _no_master
	case (((_b[0] <> 1) and (_b[1] <> 1)) and (_b[2] <> 1)) of
	true -> null
	end case;
	_sem := 1;
	to _idle

from _master
	_readers := (_readers + 1);
	_sem := 1;
	to _reading

from _reading
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	_readers := (_readers - 1);
	to _r0

from _r0
	case (_readers = 0) of
	true -> null
	end case;
	to _no_readers

from _r0
	case (_readers > 0) of
	true -> null
	end case;
	to _r1

from _no_readers
	case (((_b[0] = 1) or (_b[0] = 1)) or (_b[0] = 1)) of
	true -> null
	end case;
	_change_to := 0;
	to _change

from _no_readers
	case (((_b[0] <> 1) and (_b[0] <> 1)) and (_b[0] <> 1)) of
	true -> null
	end case;
	_change_to := 1;
	to _change

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _r1
	_sem := 1;
	to _idle


process _master_2 (&_change_to: byte, &_sem: byte, &_readers: byte, &_b: array 3 of byte) is
states _idle, _q0, _no_master, _master, _reading, _r0, _no_readers, _change, _r1

init to _idle

from _idle
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	to _q0

from _q0
	case (_b[0] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (_b[1] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (_b[2] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (((_b[0] <> 3) and (_b[1] <> 3)) and (_b[2] <> 3)) of
	true -> null
	end case;
	to _no_master

from _no_master
	case (_b[0] = 1) of
	true -> null
	end case;
	_b[0] := 3;
	to _master

from _no_master
	case (_b[1] = 1) of
	true -> null
	end case;
	_b[1] := 3;
	to _master

from _no_master
	case (_b[2] = 1) of
	true -> null
	end case;
	_b[2] := 3;
	to _master

from _no_master
	case (((_b[0] <> 1) and (_b[1] <> 1)) and (_b[2] <> 1)) of
	true -> null
	end case;
	_sem := 1;
	to _idle

from _master
	_readers := (_readers + 1);
	_sem := 1;
	to _reading

from _reading
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	_readers := (_readers - 1);
	to _r0

from _r0
	case (_readers = 0) of
	true -> null
	end case;
	to _no_readers

from _r0
	case (_readers > 0) of
	true -> null
	end case;
	to _r1

from _no_readers
	case (((_b[0] = 1) or (_b[0] = 1)) or (_b[0] = 1)) of
	true -> null
	end case;
	_change_to := 0;
	to _change

from _no_readers
	case (((_b[0] <> 1) and (_b[0] <> 1)) and (_b[0] <> 1)) of
	true -> null
	end case;
	_change_to := 1;
	to _change

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _r1
	_sem := 1;
	to _idle


process _master_3 (&_change_to: byte, &_sem: byte, &_readers: byte, &_b: array 3 of byte) is
states _idle, _q0, _no_master, _master, _reading, _r0, _no_readers, _change, _r1

init to _idle

from _idle
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	to _q0

from _q0
	case (_b[0] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (_b[1] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (_b[2] = 3) of
	true -> null
	end case;
	to _master

from _q0
	case (((_b[0] <> 3) and (_b[1] <> 3)) and (_b[2] <> 3)) of
	true -> null
	end case;
	to _no_master

from _no_master
	case (_b[0] = 1) of
	true -> null
	end case;
	_b[0] := 3;
	to _master

from _no_master
	case (_b[1] = 1) of
	true -> null
	end case;
	_b[1] := 3;
	to _master

from _no_master
	case (_b[2] = 1) of
	true -> null
	end case;
	_b[2] := 3;
	to _master

from _no_master
	case (((_b[0] <> 1) and (_b[1] <> 1)) and (_b[2] <> 1)) of
	true -> null
	end case;
	_sem := 1;
	to _idle

from _master
	_readers := (_readers + 1);
	_sem := 1;
	to _reading

from _reading
	case (_sem = 1) of
	true -> null
	end case;
	_sem := 0;
	_readers := (_readers - 1);
	to _r0

from _r0
	case (_readers = 0) of
	true -> null
	end case;
	to _no_readers

from _r0
	case (_readers > 0) of
	true -> null
	end case;
	to _r1

from _no_readers
	case (((_b[0] = 1) or (_b[0] = 1)) or (_b[0] = 1)) of
	true -> null
	end case;
	_change_to := 0;
	to _change

from _no_readers
	case (((_b[0] <> 1) and (_b[0] <> 1)) and (_b[0] <> 1)) of
	true -> null
	end case;
	_change_to := 1;
	to _change

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _change
	case (_b[0] = 3) of
	true -> null
	end case;
	_b[0] := _change_to;
	to _r1

from _r1
	_sem := 1;
	to _idle


component sys is
var 
	
	_b: array 3 of byte := [0, 0, 2], 
	
	_readers: byte, 
	
	_sem: byte := 1, 
	
	_change_to: byte

par 
	_slave_1(&_sem, &_b) 
	 || _slave_2(&_sem, &_b) 
	 || _master_1(&_change_to, &_sem, &_readers, &_b) 
	 || _master_2(&_change_to, &_sem, &_readers, &_b) 
	 || _master_3(&_change_to, &_sem, &_readers, &_b) 
end par


sys
